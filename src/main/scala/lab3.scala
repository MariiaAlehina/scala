package alokhina.lab1

object task3_1 extends App{
  // Використовуючи зіставлення зі зразком, напишіть функцію swap,
  // яка приймає пару цілих чисел і повертає ту ж пару,
  // помінявши компоненти місцями.

}

object task3_2 extends App{
  // Використовуючи зіставлення зі зразком, напишіть функцію swap,
  // яка міняє місцями перші два елементи масиву,
  // якщо він має довжину трохи менше двох.

}

object task3_3 extends App{
  // Для подання дерев, що зберігають значення тільки в листі,
  // можна використовувати списки. Наприклад, список ((3 8) 2 (5)) описує дерево
  //      •
  //    / | \
  //   •  2  •
  //  / \    |
  //  3 8    5
  // В цьому випадку одні елементи списку будуть числами, а інші - списками.
  // Однак в Scala можна створювати різнорідні списки, тому доведеться використовувати List [Any].
  // Напишіть функцію leafSum для обчислення суми всіх значень листя,
  // використовуючи зіставлення зі зразком для відділення чисел від списків.


}

object task3_4 extends App{
  // Дерева найкраще моделювати із застосуванням case-класів. Почніть з бінарних дерев.
  // sealed abstract class BinaryTree
  // case class Leaf (value: Int) extends BinaryTree
  // case class Node (left: BinaryTree, right: BinaryTree) extends BinaryTree
  // Напишіть функцію, яка обчислює суму всіх значень листя.

}

object task3_5 extends App{
  // Розширте дерево з попередньої вправи, щоб кожен вузол в ньому міг мати довільну
  // кількість дочірніх вузлів, і перепишіть функцію leafSum. Дерево в завданні 3 має виражатися як:
  // Node (Node (Leaf (3), Leaf (8)), Leaf (2), Node (Leaf (5)))

}

object task3_6 extends App{
  // Розширте дерево з попередньої вправи, щоб кожен вузол, який не є листом,
  // на додачу до дочірнім вузлів міг зберігати оператор. Потім напишіть функцію eval,
  // яка обчислює значення. Наприклад, дерево
  //    +
  //  / | \
  //  * 2 -
  // / \  |
  // 3 8  5 має значення (3 8) + 2 + (-5) = 21

}

object task3_7 extends App{
  // Визначте незмінний клас Pair [T, S] з методом swap,
  // що повертає нову пару, де компоненти поміняні місцями.

}

object task3_8 extends App{
  // Визначте змінюваний клас Pair [T] з методом swap,
  // який змінює компоненти пари місцями.

}

object task3_9 extends App{
  // Для класу Pair [T, S] напишіть узагальнений метод swap,
  // який приймає пару у вигляді аргументу і повертає нову
  // пару з компонентами, помінялися місцями.

}

object task3_10 extends App{
  // Напишіть узагальнений метод middle, який повертає середній елемент
  // з будь-якого примірника Iterable [T].
  // Наприклад, виклик middle ( "World") повинен повернути 'r'.

}

object task3_11 extends App{
  // Для змінюваного класу Pair [S, T] використовуйте механізм обмеження типу,
  // щоб визначити метод swap, який можна викликати з параметрами одного типу.

}
